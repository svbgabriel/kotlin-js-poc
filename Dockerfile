# Stage 1: Build the application with Gradle
FROM gradle:8.14.3-jdk21-alpine AS builder

WORKDIR /home/gradle/project

# Copy Gradle configuration files first to leverage Docker cache
COPY --chown=gradle:gradle settings.gradle.kts build.gradle.kts gradle.properties ./
COPY --chown=gradle:gradle gradle ./gradle

# Copy source code
COPY --chown=gradle:gradle src ./src
COPY --chown=gradle:gradle kotlin-js-store ./kotlin-js-store

# Build the application
# We use 'jsBrowserProductionWebpack' or 'jsNodeProductionRun' usually, but 'assemble' works too.
# More specific: 'jsProductionExecutableCompileSync' ensures compilation without running.
# And 'jsPackageJson' ensures package.json is created.
RUN gradle clean jsProductionExecutableCompileSync jsPackageJson --no-daemon

# Stage 2: Install production dependencies
FROM node:22-alpine AS dependencies

WORKDIR /app

# Copy package.json generated by Gradle
COPY --from=builder /home/gradle/project/build/js/packages/contacts/package.json ./package.json

# Install only production dependencies
RUN npm install --omit=dev

# Stage 3: Create the final minimal image
# Using distroless for minimal attack surface and size (~80MB compressed)
FROM gcr.io/distroless/nodejs24-debian13:latest

WORKDIR /app

# Copy dependencies from the dependencies stage
COPY --from=dependencies /app/node_modules ./node_modules

# Copy compiled application code from the builder stage
# We copy the 'kotlin' folder which contains all JS files.
COPY --from=builder /home/gradle/project/build/compileSync/js/main/productionExecutable/kotlin ./kotlin
COPY --from=builder /home/gradle/project/build/js/packages/contacts/package.json ./package.json

# Expose the port used by the application
EXPOSE 3000

# Command to run the application
# The main file is typically the project name (contacts) + .mjs
CMD ["kotlin/contacts.mjs"]
